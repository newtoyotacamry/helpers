-- loader.lua (reads your global `key`)

local HttpService = game:GetService("HttpService")
local Analytics   = game:GetService("RbxAnalyticsService")

-- ─── CONFIG ──────────────────────────────────────────────────────────────────
if not key or type(key) ~= "string" or key == "" then
    error("❌ No license key provided. Set `key = \"<your key>\"` before loading.")
end
local USER_KEY   = key
local SECRET_KEY = "efea913cc33b085341e2cda7d8c07f4fb2f9be57e820aeb5269745ba1c8001ec"
local BASE_URL      = "https://roblox-licensing-1.onrender.com"
local CHALLENGE_URL = BASE_URL .. "/loader/challenge"
local VALIDATE_URL  = BASE_URL .. "/loader/validate"

-- ─── HELPERS ─────────────────────────────────────────────────────────────────
local function simpleHMAC(input, key)
    return HttpService:UrlEncode(input .. key)
end

local function fetch(url, method, body)
    -- Exploit runtimes
    if syn and syn.request then
        return syn.request({
            Url     = url,
            Method  = method,
            Headers = { ["Content-Type"] = "application/json" },
            Body    = body or ""
        }).Body
    elseif request or http_request then
        return (request or http_request)({
            Url     = url,
            Method  = method,
            Headers = { ["Content-Type"] = "application/json" },
            Body    = body or ""
        }).Body
    end

    -- Studio fallback (must enable HTTP + whitelist domain)
    local ok, res = pcall(function()
        return HttpService:RequestAsync({
            Url     = url,
            Method  = method,
            Headers = { ["Content-Type"] = "application/json" },
            Body    = body or ""
        })
    end)
    if not ok or not res.Success then
        error(("❌ HTTP %s %s failed (status=%s)"):format(method, url, res and res.StatusCode or "nil"))
    end
    return res.Body
end

local function safeDecode(raw)
    local ok, decoded = pcall(HttpService.JSONDecode, HttpService, raw)
    return ok and decoded or nil, ok and nil or decoded
end

-- ─── 1) METADATA ──────────────────────────────────────────────────────────────
local hwid   = Analytics:GetClientId()
local gameId = tostring(game.GameId)

-- ─── 2) FETCH NONCE ──────────────────────────────────────────────────────────
local challRaw
do
    local ok, err = pcall(function()
        challRaw = fetch(CHALLENGE_URL, "POST", "")
    end)
    if not ok then error("❌ Error fetching challenge: "..tostring(err)) end
end
local chall, err = safeDecode(challRaw)
if not chall or type(chall.nonce) ~= "string" then
    error("❌ Invalid challenge response: "..tostring(err))
end

-- ─── 3) SIGN & VALIDATE ──────────────────────────────────────────────────────
local ts        = tostring(os.time())
local tokenData = chall.nonce .. ":" .. ts .. ":" .. USER_KEY
local sig       = simpleHMAC(tokenData, SECRET_KEY)

local payload = HttpService:JSONEncode({
    key       = USER_KEY,
    hwid      = hwid,
    gameId    = gameId,
    nonce     = chall.nonce,
    timestamp = ts,
    sig       = sig,
})

local validateRaw
do
    local ok, err = pcall(function()
        validateRaw = fetch(VALIDATE_URL, "POST", payload)
    end)
    if not ok then error("❌ Error fetching validate: "..tostring(err)) end
end

local resp, respErr = safeDecode(validateRaw)
if not resp then
    error("❌ Invalid validate response: "..tostring(respErr))
end
if resp.error then
    error("❌ Validation failed: "..tostring(resp.error))
end

-- ─── 4) EXECUTE ───────────────────────────────────────────────────────────────
_G._secondaryData = { timestamp = ts }

local fn, loadErr = loadstring(resp.code)
if not fn then
    error("❌ loadstring error: "..tostring(loadErr))
end
fn()
